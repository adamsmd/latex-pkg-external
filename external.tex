%% external.tex - A package for including into a document separately compiled LaTeX
%%
%% This file contains the documentation for the `external` package
%%
%% Copyright 2019 by Michael D. Adams
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
%
% The Current Maintainer of this work is Michael D. Adams.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[10pt]{ltxdoc}

% TODO: figure these out
%\EnableCrossrefs
%\CodelineIndex
%\RecordChanges

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{noindentafter} % make the \NoIndentAfterThis command available

\usepackage{xurl} % Allow url to line break anywhere

\usepackage{external}
%\externalkeys{debug=true}

\usepackage{tcolorbox}
\tcbuselibrary{listings}
\tcbuselibrary{documentation}
\tcbset{
  % Keep indentation working normally inside `docCommand` and friends
  before doc body={\parindent=15pt\NoIndentAfterThis},
  % Use the default `dispExample` formatting except don't mess with the font size
  docexample/.style={colframe=ExampleFrame,colback=ExampleBack,
    before skip=\medskipamount,after skip=\medskipamount}}

\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\com}[1]{\refCom{#1}}\newcommand{\Com}[1]{\texttt{\textbackslash#1}}
\newcommand{\env}[1]{\refEnv{#1}}\newcommand{\Env}[1]{\texttt{#1}}
\newcommand{\key}[1]{\refKey{#1}}\newcommand{\Key}[1]{\texttt{#1}}

\newcommand{\pkg}[1]{\href{https://ctan.org/pkg/#1}{\texttt{#1}}}
\newcommand{\Pkg}[1]{\texttt{#1}}

\newcommand{\showfile}[1]{
  \begin{tcolorbox}[title=\texttt{#1}]
  \verbatiminput{#1}
  \end{tcolorbox}
}

\newcommand{\sx}{%
  \rule{2pt}{4.5pt}%
  \llap{\rule[5.5pt]{2pt}{1.5pt}}%
  \llap{\rule[8pt]{2pt}{2pt}}%
}

\catcode`\<=\active
\catcode`\>=\active

\newcommand<{%
  \rule[5.5pt]{4pt}{1.5pt}%
  \llap{\sx}}
\newcommand>{%
  \rlap{\sx}%
  \rule[5.5pt]{4pt}{1.5pt}}

% TODO: error tests.  Maybe in directory and can use relative directory to use package?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

% TODO: figure these out
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2019/01/05}{Initial version}

\GetFileInfo{external.sty}

\title{The \textsf{external} package:
  A package for including into a document separately compiled LaTeX%
    \thanks{This document corresponds to
      \textsf{external}~\fileversion, dated \filedate.}}
\author{Michael D. Adams\\\url{https://michaeldadams.org}}
\date{}
\maketitle

\begin{abstract}
The \Pkg{external} package allows you to include into a document the
result of compiling \LaTeX\ code in a separate document that has its
own preamble.
This is useful when you want to use symbols from packages that you do
not want to load into your main document.
For example, your main document may use symbols from multiple packages
that conflict or otherwise cannot be loaded together.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}%
\label{sec:Introduction}

The \Pkg{external} package allows you to include into a document the
result of compiling \LaTeX\ code in a separate document that has its
own preamble.
For example, you may want to use symbols from packages that cannot be
loaded at the same time.
By compiling them in separate documents and then including their
compiled results in a master document, this allows you to use both
symbols without conflicts.

This document serves as both the documentation and test suite for the
\Pkg{external} package.

\begin{tcolorbox}[title=Warning,colback=red!5!white,colframe=red!75!black]
This package is pre-alpha and its interface may change without notice.
\end{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Quick Start}%
\label{subsec:Quick Start}

Suppose you want to use the \Com{textbeta} symbol from the
\pkg{textgreek} package, but you do do not want to load the
\pkg{textgreek} package into your master document.
(Maybe it is incompatible with some other package that you use or maybe
\LaTeX\ has run out of space for declaring new fonts.)
You can render \Com{textbeta} using the \com{external} command as in the
following.

\begin{dispExample}
An atom undergoing
\external[preamble={\usepackage{textgreek}}]{\textbeta-decay}
can emit an electron.
\end{dispExample}

If you prefer, you can also use the environment \env{externalenv} as in
the following.

\begin{dispExample}
An atom undergoing
\begin{externalenv}[preamble={\usepackage{textgreek}}]
\textbeta-decay
\end{externalenv}
~can emit an electron.
\end{dispExample}

The only difference between the command \com{external} and the
environment \env{externalenv} is that one is a command and the other is
an environment.

If you want to format the \LaTeX\ code as ``display'' math, use the
|math=display| option as in the following example.

\begin{dispExample}
The solution to the two dimensional integral
\external[preamble={\usepackage{amsmath}}, math=display]
  {\iint xy\,dx\,dy}
involves $x^2$ and $y^2$.
\end{dispExample}

Note that even though these examples are compiled as separate
\LaTeX\ documents, they are automatically properly spaced relative to
the surrounding text.
In the resulting PDF, they even behave properly with regard to
copy-and-paste.

For example, in the following, it is impossible to tell the difference
between the ``y'' generated from \com{external} and the one that is
not.
(This even handles the descender on the ``y''.)

\begin{dispExample}
xyz x\external{y}z
\end{dispExample}

However, there is a limitation to this when it comes to kerning and
ligatures.
For example, in the following, due to kerning ``T'' and ``e'' have a
different amount of space between them when using \com{external} and
when not, and putting the second ``f'' in an \com{external} command
breaks up the ``ffi'' ligature.

\begin{dispExample}
Teffi T\external{e}f\external{f}i
\end{dispExample}

See Section~\ref{sec:Options} more details about options and
Section~\ref{sec:Issues and Workarounds} for common issues and their
workarounds.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Notation}%
\label{subsec:Notation}

For debugging purposes, this documentation surrounds most examples with
|<| and |>|, which are customized to render as < and >.
These are used as a gauge or registration mark.
This makes it easy to see whether there is extra space to the left or
right of a symbol and whether parts of the symbol extend below the
baseline.
The bottom of the bottom bar is at the baseline.
The top of the top, middle and bottom bars are at the font size (10
points), where the top of an ``M'' would occur, and where the top of an
``x'' would occur, respectively.
This is demonstrated in the following example.

\begin{dispExample}
<M> <x> <>
\end{dispExample}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Related Packages}%
\label{subsec:Related Packages}

There are a number of packages that provide similar functionality to
that of \Pkg{external}.
The main distinguishing features of \Pkg{external} is that it allows
preambles to be specified for the externally compiled code and that it
does exact sizing and spacing when the compiled code is included.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Externalization}

A number of packages allow specified parts of a document to be
``externalized'' by compiling those parts as a separate
\LaTeX\ documents and then including the result in the master
document.
However, none of these allow those document parts to have a separate
preamble.

\paragraph{\pkg{tikz}}

Contains the |external| library, which caches the results of compiling
each \Env{tikzpicture} in order to improve later compilation times.
Has no support for those pictures having different preambles from the
main document.

\paragraph{\pkg{pgfplots}}

Contains the |external| library as a counterpart to the \pkg{tikz}
|external| library.

\paragraph{\pkg{preview}}

Allows extracting certain environments from \LaTeX\ sources as
graphics.
Intended for rendering ``preview'' versions of parts of a document and
used as part of \pkg{preview-latex} and AUC\TeX.
Does not support custom preambles or exact sizing.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Miniature Documents}

\paragraph{\pkg{minidocument}}

Provides the \Env{minidocument} environment, which allows an entire
miniature document to be embedded including a separate
\Com{documentclass} and preamble.
However, it assumes documents are entire pages and does not support
exact spacing.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Ignoring Preambles}%
\label{subsec:Ignoring Preambles}

Several packages allow sub-documents to be included into a master
document.
These sub-documents are full fledged \LaTeX\ documents that can be
compiled on their own, but when they are included into the master
document, either their preamble or specified parts are ignored.
These packages are geared towards helping authors manage large
documents that otherwise take a long time to compile (e.g., a book with
each chapter as a sub-document).
When compiling the master document, these packages do not compile the
sub-documents separately.
Thus, they do not support separate preambles when compiling the master
document.

\paragraph{\pkg{docmute}}

Redefines \Com{input} and \Com{include} to ignore everything between
the initial \Com{documentclass} and \Com{begin\{document\}}.

\paragraph{\pkg{includex}}

Defines versions of \Com{include} that ignore certain parts of the
included document.
Not only can it ignore everything between \Com{documentclass} and
\Com{begin\{document\}}, but it also allows ignoring anything outside
specified environments.
This package is currently unsupported.

\paragraph{\pkg{newclude}}

Adds various features to the \LaTeX\ inclusion system.
One of those features is the ability to ignore anything outside
specified environments.
This package is intended to subsume the features of \pkg{includex}, but
these features are marked as in development.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Coping Preambles from Master Files}

Another approach to including sub-documents that can be independently
compiled is to have those sub-documents automatically copy the preamble
in the master file.
As with the packages in Section~\ref{subsec:Ignoring Preambles}, these
packages are geared towards helping authors manage large documents that
otherwise take a long time to compile (e.g., a book with each chapter
as a sub-document).
When compiling the master document, these packages do not compile the
sub-documents separately.
Thus, they do not support separate preambles when compiling the master
document.

\paragraph{\pkg{subfiles}}

Defines a document class for sub-documents that automatically copies
the preamble of the master document when the sub-document is compiled,
but when the master document is compiled, everything outside the
\Env{document} environment is ignored.

\paragraph{\pkg{childdoc}}

Defines commands to be put in sub-documents instead of the standard
\Com{documentclass} and preamble.
When the sub-document is separately compiled, this automatically copies
the preamble of the master document, but when the master document is
compiled, the commands used instead of the standard \Com{documentclass}
and preamble are ignored.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Including Entire Pages}

Some packages are designed to allow completely separate documents to be
combined into one document.
For example, combining multiple articles into a proceedings.
Each document has its own preamble, but documents are included a whole
page at a time.

\paragraph{\pkg{combine}}

Allows assembling a group of individual \LaTeX\ documents into a single
document.
Also includes the \Pkg{combinet} and \Pkg{combnat} package to allow
documents to share things like table of contents.

\paragraph{\pkg{subdocs}}

Allows combining documents where each sub-document is a complete,
normal \LaTeX\ document that is typeset separately.
Shares the |.aux| files between documents so thing like the table of
contents can be kept in common.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Listing Code and Displaying the Results}

\paragraph{\pkg{tcolorbox}, \pkg{example}, \pkg{examplep}, \pkg{latexdemo}, and \pkg{showexpl}}

These packages all provide environments that display their content as
source code next to the result of rendering that code.
None of these involves separate compilation or allowing for specifying
a separate preamble.

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Minimal Page Layouts}

\paragraph{\pkg{standalone}}

Provides the document class |standalone| that produces a page with
minimal layout that is sized to fit its contents.
Does not support automatic extraction of standalone documents, and has
no support for exact sizing or including the results of compiling
standalone document.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{High-level Commands}%
\label{sec:High-level Commands}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Com{external} and \Env{externalenv}}%
\label{subsec:external and externalenv}

The main commands of this package are \Com{external} and \Env{externalenv}.

\begin{docCommand}{external}{\oarg{options}\marg{code}}

Externally compiles the the \LaTeX\ code in \meta{code} and then
includes the result.
An examples of its usage is the following.

\begin{dispExample}
<\external[preamble={\usepackage{amsmath}}, math=inline]
   {\iint xy\,dx\,dy}>
\end{dispExample}
\end{docCommand}

\begin{docEnvironment}{externalenv}{\oarg{options}}

The same as \com{external}.
The only difference is that \com{external} is a command and
\Env{externalenv} is an environment.
An example of its usage is the following.

\begin{dispExample}
<\begin{externalenv}[preamble={\usepackage{amsmath}}, math=inline]
   \iint xy\,dx\,dy
 \end{externalenv}>
\end{dispExample}
\end{docEnvironment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Com{newexternal} and \Com{newexternalenv}}%
\label{subsec:newexternal and newexternalenv}

It is sometimes useful to define versions of the \com{external} command
and the \env{externalenv} environment that have default values for
their options.
These can be created with \Com{newexternal} and \Com{newexternalenv}.
For example, you might want to define versions that load the
\pkg{amsmath} package by default.

\begin{docCommand}{newexternal}{\oarg{options}\marg{command name}}

With \Com{newexternal}, one can define a version of \com{external} that
has default values for its options.

\begin{dispExample}
<\newexternal[preamble={\usepackage{amsmath}}, math=inline]{\ams}>
<\ams{\iint xy\,dx\,dy}>
<\ams[math=false]{$\iint xyzw\,dx\,dy$}>
\end{dispExample}
\end{docCommand}

\begin{docCommand}{newexternalenv}{\oarg{options}\marg{command name}}

With \Com{newexternalenv}, one can define a version of
\env{externalenv} that has default values for its options.

\begin{dispExample}
<\newexternalenv[preamble={\usepackage{amsmath}}, math=inline]{amsenv}>
<\begin{amsenv}\iint xy\,dx\,dy\end{amsenv}>
<\begin{amsenv}[math=false]$\iint xyzw\,dx\,dy$\end{amsenv}>
\end{dispExample}
\end{docCommand}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Low-level Commands}%
\label{sec:Low-level Commands}

\begin{docCommand}{ExternalWrite}{\oarg{options}\marg{body}}\end{docCommand}

\begin{docCommand}{ExternalCompile}{\oarg{options}}\end{docCommand}

\begin{docCommand}{ExternalRead}{\oarg{options}}

Both the \com{external} command and the \env{externalenv} environment
are broken up into three phases:
\begin{enumerate}
\item writing the intermediate \LaTeX\ file,
\item compiling the intermediate \LaTeX\ file, and
\item reading the file that results from that compilation (which is
  probably a PDF file).
\end{enumerate}
These are handled with the commands \Com{ExternalWrite},
\Com{ExternalCompile}, and \Com{ExternalRead}, respectively.
For example, instead of using the command \com{external}, you could
explicitly call each of these as in the following.

\begin{dispExample}
<\ExternalWrite[file=external-external-separate,
                preamble={\usepackage{amsmath}}]
   {$\iint xy\,dx\,dy$}>
<\ExternalCompile[file=external-external-separate]>
<\ExternalRead[file=external-external-separate]>
\end{dispExample}

Taking explicit control of these is particularly useful if you want to
cache compilation results.
See the \com{ExternalCode} command for an example of this.
\end{docCommand}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{docCommand}{ExternalCode}{\marg{dim~file}\marg{preamble}\marg{before~savebox}\marg{body}\marg{before~usebox}}

This command expands to the code used in the intermediate \LaTeX\ file.
It is useful if you want to store the \LaTeX\ code to be compiled in a
separate file and reuse the compiled results between compilations
of the master \LaTeX\ file.

The \meta{dim file} is the full filename of the dimension file to
be generated.
The \meta{preamble}, \meta{before savebox}, and \meta{before usebox} are the
same as the corresponding options in Section~\ref{sec:Options}.
The \meta{body} is the \LaTeX\ code to be compiled.

For example, you might write the following standalone file.

\showfile{external-standalone-simple.tex}

Then in your master file you can compile and read that standalone file
with the following commands.

\begin{dispExample}
<\ExternalCompile[file=external-standalone-simple]>
<\ExternalRead[file=external-standalone-simple]>
\end{dispExample}

Be careful if you rename a standalone file, as you will need to change
the \meta{dim file} argument to match.
Otherwise, you will get an error along the lines of
|In \ExternalRead, input dimension file does not exist|.

Also note that \Com{ExternalCode} is defined in the \Pkg{external.code}
package.
This package is imported by the main \Pkg{external} package, so you do
not necessarily need to import it separately.
However, \Pkg{external.code} is designed be minimal and has no
dependencies.
Thus in the previous example, using |\RequirePackage{external.code}|
instead of |\RequirePackage{external}| minimizes the compilation time.
When there are a large number of standalone files, this difference can
amount to a significant amount of time.

If you wanted to reuse compiled results between compilations of the
master \LaTeX\ file, you would want to manually run the following
command.

\begin{dispListing}
pdflatex -shell-escape external-standalone-simple.tex
\end{dispListing}

Then you would omit the call to \com{ExternalCompile} and just call
\com{ExternalRead} as in the following.

\begin{dispExample}
<\ExternalRead[file=external-standalone-simple]>
\end{dispExample}
\end{docCommand}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Options}%
\label{sec:Options}

Options that are passed to commands are parsed using the \pkg{keyval}
package.
Their syntax is of the form:
\[
|[|\meta{key$_1$}|=|\meta{value$_1$}|, |\meta{key$_2$}|=|\meta{value$_2$}|, |\cdots|, |\meta{key$_n$}|=|\meta{value$_n$}|]|
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{docCommand}{externalkeys}{\marg{options}}

You can set the default value for any options with the
\Com{externalkeys} command.
For example, if want to default to use |mypdflatex| instead of
|pdflatex| to compile \LaTeX\ code, you could use the following
command.

\begin{dispListing}
\externalkeys{latex=mylatex}
\end{dispListing}

You can also specify this by passing the option when the \Pkg{external}
package is loaded as seen in the following example.

\begin{dispListing}
\usepackage[latex=mylatex]{external}
\end{dispListing}
\end{docCommand}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-level Options}%
\label{subsec:High-level Options}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{documentclass}{=\meta{class}}{initially |article|}

This option specifies the document class to be used by the intermediate
\LaTeX\ file (by way of \Com{documentclass}) that is generated for each
piece of externally compiled code.
For example, the following uses the \pkg{proc} class, which (unlike
\pkg{article}) contains the \Com{pagename} macro.

\begin{dispExample}
<\external[documentclass=proc]{\pagename}>
\end{dispExample}

If the value of this key is blank, a \Com{documentclass} declaration is
not added to the intermediate file.
In this case, you will likely want to put a \Com{documentclass}
declaration in the \key{preamble} option as in the following example.
(Though this could be achieved with |documentclass=prog|, so doing it
this way is gratuitous and solely for the sake of an example.)

\begin{dispExample}
<\external[documentclass={}, preamble={\documentclass{proc}}]
   {\pagename}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%
\begin{docKey}{documentclass/options}{=\meta{options}}{initially empty}

This option specifies options to pass to the document class to be used
by the \LaTeX\ file that is generated for externally compiled code.
For example, the following specifies passing the |12pt| option to
\pkg{article}, which changes the default font to be 12 points tall.

\begin{dispExample}
<\external[documentclass/options={12pt}]{M}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{preamble}{=\meta{code}}{initially empty}

This options specifies \LaTeX\ code to be put in the preamble of the
intermediate \LaTeX\ file that is generated for externally compiled
code.
For example, you might want to load packages as in the following.

\begin{dispExample}
<\external[preamble={\usepackage{amsmath}}]{$\iint xy\,dx\,dy$}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{math}{=\meta{\docValue{false}, \docValue{inline}, or \docValue{display}}}{initially \docValue{false}}

This option controls whether the body of \com{external} or
\env{externalenv} is treated as math, and if so, whether it is inline
math or display math.
The following demonstrate each value possible for this option.

\begin{dispExample}
<\external[preamble={\usepackage{amsmath}}, math=false]
   {$\iint xy\,dx\,dy$}>
\end{dispExample}

\begin{dispExample}
<\external[preamble={\usepackage{amsmath}}, math=inline]
   {\iint xy\,dx\,dy}>
\end{dispExample}

\begin{dispExample}
<\external[preamble={\usepackage{amsmath}}, math=display]
   {\iint xy\,dx\,dy}>
\end{dispExample}

Note that |math=display|, as seen in the following example, is
equivalent to the incantation |\[\external{$\displaystyle...$}\]|.

\begin{dispExample}
<\[\external[preamble={\usepackage{amsmath}}]
     {$\displaystyle\iint xy\,dx\,dy$}\]>
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{margin/top}{=\meta{length}}{initially |1in|}\end{docKey}
\begin{docKey}{margin/bottom}{=\meta{length}}{initially |1in|}\end{docKey}
\begin{docKey}{margin/left}{=\meta{length}}{initially |1in|}\end{docKey}
\begin{docKey}{margin/right}{=\meta{length}}{initially |1in|}

These options specify the margin to place around the \LaTeX\ code being
compiled externally.
This is useful if the \LaTeX\ code being compiled externally draws
outside its bounding box.
If there is not enough margin to contain the drawn portions, the result
may be clipped.
For example, compare the two following examples.
The 2-inch rules are clipped when the default (1-inch) margins are used
but are not clipped when 3-inch margins are used.

\begin{dispExample}
\vspace{2in}
\hspace{2in}
<\begin{externalenv}
   \rlap{\rule[3pt]{2in}{1pt}}%
   \llap{\rule[3pt]{2in}{1pt}}%
   \smash{\rule[-2in]{1pt}{4in}}%
 \end{externalenv}>
\vspace{2in}
\end{dispExample}

\begin{dispExample}
\vspace{2in}
\hspace{2in}
<\begin{externalenv}[margin/top=3in, margin/bottom=3in,
                     margin/left=3in, margin/right=3in]
   \rlap{\rule[3pt]{2in}{1pt}}%
   \llap{\rule[3pt]{2in}{1pt}}%
   \smash{\rule[-2in]{1pt}{4in}}%
 \end{externalenv}>
\vspace{2.2in}
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Low-level Options}%
\label{subsec:Low-level Options}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{before}{=\meta{code}}{initially |\textbackslash{}stepcounter\{external@number\}|}

This option specifies \LaTeX\ code to run before the rest of the code
in an \com{external} command or \env{externalenv} environment.
This is particularly useful for incrementing any counters used in the
\key{file} option.
The following is an example of this in action.

\begin{dispExample}
\newcounter{foo}%
\thefoo
<\external[file=external-external-before,
           before={\stepcounter{foo}}]{}>%
\thefoo
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{before compile}{=\meta{code}}{initially empty}

With an \com{external} command or \env{externalenv} environment, this
option specifies \LaTeX\ code to run after writing the file for the
externally complied code but before compiling the externally compiled
code.
The following is an example of this in action.

\begin{dispExample}
\newcounter{baz}%
\thebaz
<\external[file=external-external-before-compile,
           before compile={\stepcounter{baz}}]{}>%
\thebaz
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{before read}{=\meta{code}}{initially empty}

In an \com{external} command or \env{externalenv} environment, this
option specifies \LaTeX\ code to run after compiling the externally
compiled code but before reading the file output by the externally
compiled code.
The following is an example of this in action.

\begin{dispExample}
\newcounter{quux}%
\thequux
<\external[file=external-external-before-read,
           before read={\stepcounter{quux}}]{}>%
\thequux
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{after}{=\meta{code}}{initially empty}

This option specifies \LaTeX\ code to run after the rest of the code
in an \com{external} command or \env{externalenv} environment.
The following is an example of this in action.

\begin{dispExample}
\newcounter{bar}%
\thebar
<\external[file=external-external-after,
           after={\stepcounter{bar}}]{}>%
\thebar
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{before savebox}{=\meta{code}}{initially empty}

This option specifies code to be put before the \Com{savebox} that is
used in the intermediate \LaTeX\ file that is generated for externally
compiled code.
This option corresponds to the \meta{before savebox} argument of
\com{ExternalCode}.

This option is rarely needed.

The following example demonstrates the use of this option, though since
the definition of \Com{p} could be put in the preamble, putting it in
\Key{before savebox} is gratuitous and solely for the sake of an example.

\begin{dispExample}
<\external[before savebox={\newcommand{\p}[1]{(##1)}}]{\p{x}}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{before usebox}{=\meta{code}}{initially empty}

This option specifies code to be put before the \Com{usebox} that is
used in the intermediate \LaTeX\ file that is generated for externally
compiled code.
This option corresponds to the \meta{before usebox} argument of
\com{ExternalCode}.

This option is rarely needed.

The following example demonstrates the use of this option, though since
there are other ways to accomplish this effect, using \Key{before usebox}
is gratuitous and solely for the sake of an example.
Note that we have to set the margins to small or zero lengths to
prevent them from overlapping the rest of the page.

\begin{dispExample}
<\external[preamble={\usepackage{xcolor}},
           before usebox={\pagecolor{gray!50}},
           margin/top=1pt, margin/bottom=1pt,
           margin/left=0pt, margin/right=0pt]
   {ABC}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{latex}{=\meta{program name}}{initially empty}

This option specifies the program to use to compile the intermediate
\LaTeX\ file that is generated for each bit of externally compiled
code.

Blank means to autodetect between |pdflatex|, |xelatex|, or |lualatex|
to match whatever the master document is being compiled with.

For example, if you wanted to force certain code to run under
|pdflatex|, you could do the following.

\begin{dispExample}
<\external[latex=pdflatex]{\pdfescapehex{ABC}}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%
\begin{docKey}{latex/options}{=\meta{code}}{initially |-halt-on-error -interaction=batchmode|}

This option specifies what command-line options to pass to \LaTeX\ when
compiling the intermediate \LaTeX\ file that is generated for
externally compiled code.

Note that if you change this, you will almost certainly want to include
the |-halt-on-error| and |-interaction=batchmode| options in whatever
you change it to.

For example, the \pkg{ifplatform} package needs the |-shell-escape|
option in order to give precise platform information.
This can be specified as in the following.

\begin{dispExample}
<\external[preamble={\usepackage{ifplatform}}]
   {\platformname}>
<\external[preamble={\usepackage{ifplatform}},
           latex/options={-shell-escape -halt-on-error
                          -interaction=batchmode}]
   {\platformname}>
\end{dispExample}

Note that if this document was compiled on Windows, then the two calls
to \com{external} in this example will produce the same results as each
other, but on any other platform they will be different.
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{file}{=\meta{file basename}}{initially |\textbackslash{}jobname-external-\textbackslash{}arabic\{external@number\}|}

This option specifies the basename of the intermediate files that are
generated for externally compiled code.

For example, the following uses |external-external-file| as the
basename.

\begin{dispExample}
<\external[file=external-external-file,
           preamble={\usepackage{amsmath}}]
   {$\iint xy\,dx\,dy$}>
\end{dispExample}

Be careful not to use the same filename for two different pieces of
externally compiled code as that can lead to unexpected results.
\end{docKey}

%%%%%%%%%%
\begin{docKey}{file/tex}{=\meta{extension}}{initially |.tex|}\end{docKey}
\begin{docKey}{file/dim}{=\meta{extension}}{initially |.dim|}\end{docKey}
\begin{docKey}{file/out}{=\meta{extension}}{initially |.pdf|}

These options specify the extensions to use for the intermediate
\LaTeX, dimension, and compiled files, respectively.

These options are rarely needed.

An example of using them is the following.

\begin{dispExample}
\DeclareGraphicsRule{.mypdf}{pdf}{.mypdf}{}%
<\external[
   file/tex=.mytex, file/dim=.mydim, file/out=.mypdf,
   file=external-external-extension,
   before read={\ShellEscape{mv external-external-extension.pdf
                                external-external-extension.mypdf}}]
   {ABC}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{includegraphics/options}{=\meta{key-value sequence}}{initially empty}

This option specifies options to be passed to the \Com{includegraphics}
command that is used to read into the master document the result of
compiling the \LaTeX\ code that is compiled separately.
For example, the following uses \Key{angle} to rotate the image read by
\Com{includegraphics}.

\begin{dispExample}
<\external[includegraphics/options={angle=45}]{M}>
\end{dispExample}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%
\begin{docKey}{debug}{=\meta{\docValue{true} or \docValue{false}}}{initially \docValue{false}}

Whether to print tracing information to standard out.
This is helpful in determining exactly what part of a command failed.

For example, consider the following call to \com{external}.

\begin{dispExample}
<\external[preamble={\usepackage{amsmath}}]{$\iint xy\,dx\,dy$}>
\end{dispExample}

When the \Key{debug} option is |true|, lines like the following will be
printed to the standard output.

\begin{dispListing}
**** Begin \ExternalWrite on {external-external-21}
       with {$\iint xy\,dx\,dy$}
**** End \ExternalWrite on {external-external-21}
**** Begin \ExternalCompile on {external-external-21}
**** End \ExternalCompile on {external-external-21}
**** Begin \ExternalRead on {external-external-21}
**** End \ExternalRead on {external-external-21}
\end{dispListing}
\end{docKey}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Issues and Workarounds}%
\label{sec:Issues and Workarounds}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Document Not Updating}%
\label{subsec:Document Not Updating}

A common issue is when changing the \LaTeX\ code to be externally
compiled (e.g., the \meta{body} of a \com{external}), but those changes
are not reflected in the master document after re-compiling the master
document.
The cause of this is that \Pkg{external} has no way to detect whether
compiling the intermediate \LaTeX\ file succeeded or failed.
A failure can happen for example if the \LaTeX\ code to be externally
compiled contains an error that causes the compilation of the
intermediate \LaTeX\ file to fail.
If compilation of the intermediate \LaTeX\ file fails, the dimension
file and the resulting compiled, PDF file from previous compilation
will not be overwritten.

To fix this, delete the PDF and dimension files.
Then failure of the compilation of the intermediate \LaTeX\ file will
cause a file-not-found error when the PDF and dimension file are read.
You can then fix the error in the \LaTeX\ code to be externally
compiled and use this file-not-found error to let you know when you
have fixed that \LaTeX\ code.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hash Symbols and Command Arguments}%
\label{subsec:Hash Symbols and Command Arguments}

The use of hashes symbols that one would use when referencing a command
argument (e.g., |#1|) can lead to problems.
For example, the following would lead to an error.

\begin{dispListing}
<\external[preamble={\newcommand{\p}[1]{(#1)}}]{\p{x}}>
\end{dispListing}

The solution to this is to use double hashes (for example, |##1|
instead of |#1|) as demonstrated in the following.

\begin{dispExample}
<\external[preamble={\newcommand{\p}[1]{(##1)}}]{\p{x}}>
\end{dispExample}

\begin{dispExample}
<\begin{externalenv}[preamble={\newcommand{\p}[1]{(##1)}}]
   \p{x}
 \end{externalenv}>
\end{dispExample}

This even applies in the body of an \com{external} or \env{externalenv}
as seen in the following.

\begin{dispExample}
<\external{\newcommand{\p}[1]{(##1)}\p{x}}>
\end{dispExample}

\begin{dispExample}
<\begin{externalenv}
   \newcommand{\p}[1]{(##1)}%
   \p{x}
 \end{externalenv}>
\end{dispExample}

This also applies to standalone files as seen in the following.

\showfile{external-standalone-hash.tex}

\begin{dispExample}
<\ExternalCompile[file=external-standalone-hash]>
<\ExternalRead[file=external-standalone-hash]>
\end{dispExample}

Finally, \com{newexternal} and \com{newexternalenv} require
\textit{four} hashes due to an extra level of indirection occurring in
them as demonstrated in the following examples.

\begin{dispExample}
<\newexternal[preamble={\newcommand{\p}[1]{(####1)}}]{\paren}>
<\paren{\p{x}}>
\end{dispExample}

\begin{dispExample}
<\newexternalenv[preamble={\newcommand{\p}[1]{(####1)}}]{paren}>
<\begin{paren}\p{x}\end{paren}>
\end{dispExample}

However, in their bodies this does not apply and only two hashes should
be used as demonstrated in the following.

\begin{dispExample}
<\newexternal{\paren}>
<\paren{\newcommand{\parens}[1]{(##1)}\parens{x}}>
\end{dispExample}

\begin{dispExample}
<\newexternalenv{paren}>
<\begin{paren}
   \newcommand{\parens}[1]{(##1)}%
   \parens{x}
 \end{paren}>
\end{dispExample}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Category Codes}%
\label{subsec:Category Codes}

Some commands change the category codes of many characters.
These pose a problem for use with commands from this \Pkg{external}
package as the arguments to commands are parsed before those category
codes have changed.
The way to work around this is to use the \Com{scantokens} macro to
cause parts of those arguments to be re-parsed.

For example, the \Com{DeclareFontShape} macro redefines category codes
for characters used in its argument.
Thus to use it one must insert a call to \Com{scantokens} as in the
following.

\begin{dispExample}
<\external[preamble={
             \usepackage{pifont}
             \DeclareFontFamily{U}{msa}{}
             \scantokens{
               \DeclareFontShape
                 {U}{msa}{m}{n}
                 {<-6>msam5<6-8>msam7<8->msam10}{}\relax}}]
   {\Pisymbol{msa}{15}}>
\end{dispExample}

The \Com{relax} before the end of the argument to \Com{scantokens}
ensures that \Com{scantokens} does not insert an extra space at the end.
See
\url{https://tex.stackexchange.com/questions/117906/use-of-everyeof-and-endlinechar-with-scantokens}
for details.

This trick also works when using a standalone file as in the following.

\showfile{external-standalone-catcode.tex}

\begin{dispExample}
<\ExternalCompile[file=external-standalone-catcode]>
<\ExternalRead[file=external-standalone-catcode]>
\end{dispExample}

\printindex

\end{document}
